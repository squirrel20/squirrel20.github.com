---
layout: post
title: "《编译原理 第2版》第1章 引论"
description: ""
category: "读书笔记"
tags: [读书笔记,编译原理]
---
{% include JB/setup %}

## 1.1 语言处理器

*编译器*

编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成为一个等价的，用另一种语言（目标语言）编写的程序。编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误。

	源程序 -> 『编译器』 -> 目标程序

一般的过程是，经过预处理（预处理器）的源程序作为输入传递给一个编译器，编译器可能产生一个汇编语言程序作为输出，因为汇编语言比较容易输出和调试。

*目标程序*

如果目标程序是一个可执行的机器语言程序，那么它就可以被用户调用，处理输入并产生输出。

	输入 -> 『目标程序』 -> 输出

*解释器*

从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。

	源程序 + 输入 -> 『解释器』 -> 输出

*编译器和解释器的比较*

在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而解释器的错误诊断通常比编译器更好，因为它逐个语句地执行源程序（？为什么逐个语句执行源程序就能更好诊断出错误呢，是不是因为执行某一语句出错了，那么就可以直接退出，然后得出该语句执行出错）。

*Java语言处理器*

Java语言处理器结合了编译和解释过程。一个Java源程序首先被编译成一个称为字节码（bytecode）的中间表示形式。然后由一个虚拟机对得到的字节码加以解释执行。这样安排的好处之一是在一台机器上编译得到的字节码可以在另一台机器上解释执行。通过网络就可以完成机器之间的迁移。

	（源程序 -> 『翻译器』 -> 中间程序） + 输入 -> 『虚拟机』 -> 输出

*即时编译器*

为了更快地完成输入到输出的处理，有些被称为即时编译器的Java编译器在运行中间程序处理输入的前一刻首先把字节码翻译称成为机器语言，然后再执行程序。

*预处理器*

一个源程序可能被分割成为多个模块，并存放于独立的文件中。把源程序聚合在一起的任务有时会由一个被称为预处理器（preprocessor）的程序独立完成。预处理器还负责把那些称为宏的缩写形式转换为源语言的语句。

	源程序 -> 『预处理器』 -> 经过预处理的源程序

*汇编器*

汇编器将汇编语言程序作为输入，生成可重定位的机器代码。

	目标汇编程序 -> 『汇编器』 -> 可重定位机器代码

*链接器*

大型程序经常被分成多个部分进行编译，因此，可重定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，形成真正的机器上运行的代码。一个文件中的代码可能指向另一个文件中的位置，而链接器（linker）能够解决外部内存地址的问题。

*加载器*

加载器把所有的可执行目标文件放到内存中执行。

	可重定位机器代码 + 库文件/可重定位库文件 -> 『链接器/加载器』 -> 目标机器代码

<!--more-->

## 1.2 一个编译器的结构

编译器：把源程序*映射*为在语义上等价的目标程序。映射的过程由两个部分组成：分析部分和综合部分。

分析（analysis）部分把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后，它使用这个结构来创建该远程的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表（symbol table）的数据结构中。符号表将和中间表示形式一起传送给综合部分。

综合（synthesis）部分根据中间表示和符号表中的信息来构造用户期待的目标程序。

分析部分经常被称为编译器的前端（front end），而综合部分称为后端（back end）。总结下来，源程序到目标程序的过程就是：

	源程序 -> 『分析』 -> 中间表示形式 + 符号表 -> 『综合』 -> 目标程序

一个典型的把编译程序分解成为多个步骤的方式如下：

	字符流 -> 『词法分析器』 -> 符号流 -> 『语法分析』 -> 语法树 -> 『语义分析』 -> 语法树 -> 『中间代码生成器』 -> 中间表示形式 -> 『机器无关代码优化器』 -> 中间表示形式 -> 『代码生成器』 -> 目标机器语言 -> 『机器相关代码优化器』 -> 目标机器语言

其中分析部分可以包括：词法分析器、语法分析、语义分析和中间代码生成器。综合部分可以包括：代码生成器和机器相关代码优化器。机器无关代码优化器是可选的。

### 1.2.1 词法分析（扫描）

词法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素（lexeme）的序列。

对于每个词素，词法分析器产生如下的词法单元（token）作为输出：

	<token-name, attribute-value>

词法单元被传送给语法分析器。其中，第一个分量token-name是一个由语法分析步骤使用的抽象符号，而第二个分量attribute-value指向符号表中关于这个词法单元的条目。该条目的信息会被语义分析和代码生成步骤使用。

#### 一个例子

假设一个源程序包含如下的赋值语句

	position = initial + rate * 60

1. 词素 position，对应的词法单元<id, 1>，其中id是表示标识符（identifier）的抽象符号，而1指向符号表中position对应的条目。一个标识符对应的符号表条目存放该标识符有关的信息，比如它的名字和类型。
2. 词素 =，对应的词法单元<=>。
3. 词素 initial，对应的词法单元<id, 2>，其中2指向initial对应的符号表的条目。
4. 词素 +，对应的词法单元<+>。
5. 词素 rate，对应的词法单元<id, 3>。
6. 词素 *，对应的词法单元<*>。
7. 词素 60，对应的词法单元<60>。（其实应该是<number, 4>）

那么上面的赋值语句对应的词法单元序列为：

	<id, 1> <=> <id, 2> <+> <id, 3> < * > <60>

### 1.2.2 语法分析（解析）

语法分析器使用由词法分析器生成的各词法单元的第一个分量来创建树形的中间表示。

该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法是语法树（syntax tree），树中的每个内部结点表示一个运算，而该结点的子节点表示该运算的分量。

### 1.2.3 语义分析

语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。

语义分析的一个重要部分是类型检查。编译器检查每个运算符是否具有匹配的运算分量。

语义错误就是从这报出的吧。

### 1.2.4 中间代码生成

在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示具有两个重要性质：

1. 易于生成；
2. 能够轻松地翻译为目标机器上的语言。

三地址代码的中间表示形式，这种中间表示由一组类似于汇编语言的指令组成，每个指令具有三个运算分量。每个运算分量都像一个寄存器。对于上面的赋值语句，其三地址代码序列：

	t1 = inttoflaot(60)
	t2 = id3 ＊t1
	t3 = id2 + t2
	id1 = t3

三地址代码遵循如下规则：

1. 每个三地址赋值指令的右部最多只有一个运算符。
2. 编译器应该生成一个临时名字以存放一个三地址指令计算得到的值。
3. 有些三地址指令的运算分量少于三个。

### 1.2.5 代码优化

机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。

对于上面的中间代码，其优化后的结果为：

	t1 = id3 * 60.0
	id1 = id2 + t1

### 1.2.6 代码生成

代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。

如果目标语言是机器代码，那么就必须为程序使用的每个变量选择寄存器或内存位置。然后，中间指令被翻译成为能够完成相同任务的机器指令序列。代码生成的一个至关重要的方面是合理分配寄存器以及存放变量的值。

### 1.2.7 符号表管理

符号表数据结构为每个变量名字创建了一个记录条目。记录的字段就是名字的各个属性。这个数据结构应该允许编译器迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据。

## 1.3 程序设计语言的发展历程

*通过语言的代来分类*

* 第一代语言：机器语言。
* 第二代语言：汇编语言。
* 第三代语言：高级程序设计语言。如Fortran, Cobol, Lisp, C, C++, C#和Java等。
* 第四代语言：为特定应用设计的语言。如NOMAD(用于生成报告)，SQL（用于数据库查询）和Postscript（文本排版）。
* 第五代语言：基于逻辑和约束的语言。如Prolog和OPS5等。

*另一种分类方式*

* 强制式语言：指明如何完成一个计算任务。如C, C++, C#和Java等。
* 声明式语言：指明要进行哪些计算的语言。如ML和Hashkell这样的函数式语言，Prolog这样的约束逻辑语言。

*按计算机体系结构分类*

* 冯诺依曼语言：以冯诺依曼计算机体系结构为计算模型的程序设计语言。如C和Fortran。

* 面向对象语言：指的是支持面向对象编程的语言，面向对象编程是指用一组相互作用的对象组成程序的编程风格。如C++, C#, Java和Ruby等。
* 面向过程语言：以过程为中心，主要采取程序调用或函数调用的方式来进行流程控制。如C。

* 脚本语言：具有高层次预算符的解释性语言，它通常被用于多个计算过程”粘合“在一起。如Awk, JavaScript, Perl, PHP, Python, Ruby和Tcl等。

## 1.4 构建一个编译器的相关科学

编译器的设计中有很多通过数学方法抽象出问题本质从而解决现实世界中复杂问题的完美例子。这些例子可以被用来说明如何使用抽象方法来解决问题：接受一个问题，写出抓住子问题的关键特性的数学抽象表示，并用数学技术来解决它。问题的表达必须根植于对计算机程序特性的深入理解，而解决方法必须使用经验来验证和精化。（这段话说的真好）

### 1.4.1 编译器设计和实现中的建模

对编译器的研究主要是有关如何设计正确的数学模型和选择正确算法的研究。设计和选择时，还需要考虑到对通用性及功能的要求与简单性及有效性之间的平衡。

### 1.4.2 代码优化的科学

编译器优化必须满足下面的设计目标：

* 优化必须是正确的，也就是说，不能改变编译器程序的含义。
* 优化必须能够改善很多程序的性能。
* 优化所需的时间必须保持在合理的范围内。
* 所需要的工程方面的工作必须是可管理的。

> （作者大大的良心啊）

> 在研究编译器时不仅要学习如何构造一个编译器，还要学习解决复杂和开放性问题的一般方法学。

## 1.5 编译技术的应用

### 1.5.1 高级程序设计语言的实现

一个高级程序设计语言定义了一个编程抽象：程序员使用这个语言表达算法，而编译器必须把这个程序翻译成目标语言。

C语言中的关键字register是编译器技术和语言发展互动的一个较早的例子。在早期，人们认为有必要让程序员来控制哪个程序变量应该存放在寄存器中。当有效的寄存器分配技术出现后，这个控制变得没有必要了。

实际上，是用关键字register的程序还可能损失效率，因为寄存器分配是一类很低层次的问题，程序员常常不是最好的判断这类问题的人选（也可以说，程序员现在很少接触低层次的问题）。寄存器分配的最优选择很大程度上取决于机器的体系结构特点。把低层次资源管理的决策，比如寄存器分配，写死在程序中反而有可能损害性能。当运行程序的计算机有别于当初所设定的目标机时更是如此。

### 1.5.2 针对计算机体系结构的优化

几乎所有的高性能系统都利用了两种技术：并行（parallelism）和内存层次结构（memory hierarchy）。

*并行性*

并行可以出现在多个层次上：在指令（机器指令）层次上，多个运算可以被同时执行；在处理器层次上，同一个应用的多个不同线程在不同的处理器上运行。

所有的现代微处理器都采用了指令集并行性。但是，这种并行可以对程序员隐藏起来。程序员写程序的时候就好像所有指令都是顺序执行的。硬件动态地检测顺序指令流之间的依赖关系，并且在可能的时候并行地发出指令。在有些情况下，机器包含一个硬件调度器。该调度器可以改变指令的顺序以提高程序的并行性。不管硬件是否对指令进行重新排序，编译器都可以重新安排指令，以使得指令集并行更加有效。

*内存层次结构*

内存层次结构是应对下述局限性的方法：我们可以制造非常快的内存，或者非常大的内存，但是无法制造非常大又非常快的内存。

一个内存层次结构由几层具有不同速度和大小的存储器组成。

### 1.5.3 新计算机体系结构的设计

使用高级程序设计语言是一种规范，规定一个计算机系统性能的不是它的原始速度，还包括编译器能够以何种程度利用其特征。因此，在现代计算机体系结构的开发中，编译器在处理器设计阶段就进行开发，然后编译得到代码并运行于模拟器上。这些代码被用来评价提议的体系结构特征。

*RISC（Reduced Instruction-Set Computer，精简指令集计算机）*

与RISC相对应的是CISC（Comples Instruction-Set Computer，复杂指令集计算机），CISC指令集很复杂，目的是使汇编编程变得更容易。

编译器优化经常能够消除复杂指令之间的冗余，把这些指令消减为少量较简单的运算。

大部分通用处理器体系结构（PowerPC、SPARC、MIPS、Alpha和PA-RISC）都是基于RISC概念的。X86体系结构（最流行的微处理器）具有CISC指令集，但在这个处理器本身的实现中使用了很多为RISC机器发展得到的思想。使用高性能的x86机器的最有效的方法是仅使用它的简单指令。
