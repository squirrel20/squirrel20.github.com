---
layout: post
title: "读书笔记（5）：UNIX网络编程 卷1：套接字联网API：第15章：Unix域协议"
description: ""
category: "UNIX网络编程 卷1：套接字联网API"
tags: [读书笔记]
---
{% include JB/setup %}

Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法，所用API就是在不同主机上执行客户/服务器通信所用的API（套接字API）。Unix域中用于标识客户和服务器的协议地址是普通文件系统中的路径名。这些路径名不是普通的Unix文件：除非把它们和Unix域套接字关联起来，否则无法读写这些文件。

### 使用Unix域套接字的3个理由

1. 在源自Berkeley的实现中，Unix域套接字往往比通信两端位于同一个主机的TCP套接字快出一倍。
2. Unix域套接字可用于在同一主机上的不同进程之间传递描述符。
3. Unix域套接字较新的实现把客户的凭证（用户ID和组ID）提供服务器，从而能够提供额外的安全措施。

### Unix域套接字地址结构

{% highlight c %}
#include <sys/un.h>

struct sockaddr_un {
	sa_family_t		sun_family;			/* AF_LOCAL */
	char			sun_path[140];		/* null-terminated pathname */
}
{% endhighlight %}

存放在sun_path数组中的路径名必须以空字符结尾。

### socketpair函数

socketpair函数创建两个随后连接起来的套接字。*本函数仅适用于Unix域套接字。*

{% highlight c %}
#include <sys/socket.h>

int socketpair (int family, int type, int protocol, int sockfd[2]);
// 返回：若成功则为非0，返回两个彼此连接的描述符，若出错则为-1
{% endhighlight %}

family参数必须为AF_LOCAL，protocol参数必须为0。type参数即可以使SOCK_STREAM，也可以是SOCK_DGRAM。新创建的两个套接字描述符作为sockfd[0]和sockfd[1]返回。

制定type参数为SOCK_STREAM调用socketpair得到的结果称为*流管道（stream pipe）*。它域调用pipe创建的普通Unix管道类似，差别在于流管道是全双工的，即两个描述符都是即可读又可写的。

<!--excerpt-->

### 套接字函数在Unix域中的差异和限制

1. 由bind创建的路径名默认访问权限应为0777（属主用户、组用户和其他用户都可读、可写并可执行），并按umask值进行修正。
2. 与Unix域套接字关联的路径名应该是一个绝对路径名，而不是一个相对路径名。避免使用后者的原因是它的解析依赖于调用者的当前工作目录。
3. 在connect调用中指定的路径名必须是一个当前绑定在某个打开的Unix域套接字上的路径名，而且它们的套接字类型（字节流或数据包）也必须一致。出错条件包括：（a）该路径名已存在却不是一个套接字；（b）该路径名已存在且是一个套接字，不过没有与之关联的打开的描述符；（c）该路径名已存在且是一个套接字，不过类型不符（字节流或数据包之间不能传递数据）。
4. 调用connect连接一个Unix域套接字涉及的权限测试等同于调用open以只写方式访问相应的路径名。
5. Unix域字节流套接字类似于TCP套接字：它们都为进程提供一个无记录边界的字节流接口。
6. 如果对于某个Unix域字节流套接字的connect调用发现监听套接字的队列已满，调用就立即返回一个ECONNREFUSED错误。这一点不同于TCP：如果TCP监听套接字的队列已满，TCP监听套接字忽略新到达的SYN，而TCP连接发起端将数次发送SYN进行重试。
7. Unix域数据报套接字类似于UDP套接字：它们都提供一个保留记录边界的不可靠的数据报服务。
8. 在一个未绑定Unix域套接字上发送数据报不会自动给这个套接字绑定一个路径名，这一点不同于UDP套接字：在一个未绑定的UDP套接字上发送UDP数据报导致这个套接字捆绑一个临时端口。这一点意味着除非数据报发送端已经捆绑一个路径名到它的套接字，否则数据报接收端无法发回应答数据报。类似地，对于某个Unix域数据报套接字的connect调用不会给本套接字捆绑一个路径名，这一点不同于TCP和UDP。