---
layout: post
title: "《AMQP》"
description: "通用中间件标准"
category: "读书笔记"
tags: [读书笔记, amqp]
---
{% include JB/setup %}

版本：0-10

## 1. 概述

### 1.1 文档的作用

该文档定义了一个网络协议：AMQP（Advanced Message Queuing Protocol），遵循该协议的客户应用程序和消息中间件服务器之间可以相互通信。

### 1.2 专利

### 1.3 总览

#### 1.3.1 什么是AMQP

AMQP（Advanced Message Queuing Protocol），遵循该协议的客户应用程序和消息中间件服务器之间可以相互通信。

#### 1.3.2 为什么设计AMQP协议

就是为了整一种通用的消息中间件协议嘛，希望大家都用这种协议。

#### 1.3.3 AMQP包含什么

1. AMQP模型，由一系列组件组成，组件在代理内部路由和存储消息，组件之间通过一系列的规则相互连接。
2. 一个网络层协议：AMQP。客户应用程序通过这个协议与代理通信，与AMQP模型交互。

#### 1.3.4 高级消息队列协议（AMQP）

*AMQP模型*

AMQP模型主要包含下面三个组件：

1. 交换机组件：接收来自生产者应用的消息，将消息路由到消息队列。
2. 消息队列组件：存储消息直到消息被消费者应用消费。
3. 绑定组件：定义消息队列组件和交换组件之间的关系，指定路由规则。

通过上面三个组件可以简单实现中间件的概念：存储转发队列，主题订阅。

> 中间件（Middleware）是提供系统软件和应用软件之间链接的软件，以便于软件各部件之间的沟通。

> 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。

> 消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。
> 消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件机制的系统中，不同的对象之间通过传递消息来激活对方的事件，完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。消息中间件能在不同平台之间通信，它常被用来屏蔽掉各种平台及协议之间的特性，实现应用程序之间的协同，其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发。

AMQP模型的目标：

1. 支持金融服务行业所需的语义。
2. 提供金融服务行业所需的性能水平。
3. 有新的消息路由和队列仍然容易扩展。
4. 通过协议，服务器所允许的特定语义由应用程序编程指定。
5. 灵活而简单。

<!--more-->

*AMQP协议*

![AMQP Protocol]({{ CDN_PATH }}{{ site.img_url }}/2014090501.png)

AMQP分为三层：

1. 模型层定义了一系列的命令，应用程序使用这些命令与服务器交互。
2. 会话层保证从应用程序到服务器的命令能够可靠传输。
3. 传输层提供框架、多路复用通道、错误检测和数据表示（？data representation）。

#### 1.3.5 包括的功能

支持多种通讯架构：

1. 基于存储转发的多写单读。
2. 基于事务分布的多写多读。
3. 基于发布订阅的多写多读。
4. 基于内容路由的多写多读。
5. 基于排队文件传输的多写多读。
6. 两个结点间的点对点连接。

注：多写多读指多个用户写和多个用户读，多写单读指多个用户写和单个用户读。

### 1.4 文档组织结构

分档份两部分：

1. 概念，介绍AMQP的概念，如何使用AMQP。
2. 技术说明，介绍AMQP语义，包括模型层、会话层和通过网络传输AMQP的方式。

### 1.5 惯例

1. AMQP模型（AMQP Model）：表示关键实体的逻辑框架和语义，由AMQP服务器实现。
2. 连接（Connection）：网络连接，如TCP/IP套接字连接。
3. 会话（Session）：节点之间的命名对话框。在会话上下文中，要保证仅以此交付。
4. 通道（Channel）：在多路复用连接（Connection）中的独立双向流。是会话（Session）的物理连接。即会话是逻辑上的，通道是物理上的，两者对应。
5. 客户端（Client）：AMQP连接或会话的发起者。AMQP不是对称的，即客户端产生和消费消息，服务端将消息入队和路由。
6. 服务端（Server）：一个进程，接收来自客户端的连接，实现AMQP消息队列和路由功能。又叫做代理（broker）。
7. 节点：AMQP会话的一端。一个AMQP连接包括两个节点，一个是客户端，一个是服务端。
8. 帧（Frame）：AMQP的传输单元。一帧是一段的任意片段。
9. 段（Segment）：帧的有序集合，是集合中的一个完整的语法划分。
10. 集合（Assembly）：段的有序集合，一个任务的逻辑单元。
11. 头部（Header）：一种特定类型的段，描述消息数据的属性。
12. 主体（Body）：一种特定类型的段，包括应用数据。主体段完全不透明，服务端不能检查或修改这主体。
13. 内容（Content）：包含在主体段中的消息数据。
14. 控制（Control）：假定在不可靠传输情况下的单向指令。
15. 命令（Command）：需要对方确认的指令。则是可靠传输命令。
16. 类（Class）：AMQP命令集或是控制集，处理一个特定的功能。
17. *交换机（Exchange）*：服务端的一个实体从生产者应用程序处获取消息，并把消息路由到服务端的消息队列中。
18. 交换类型（Exchange Type）：基于路由语义的交换分类。
19. 消息队列（Message Queue）：一个命名实体，保存消息直到可以把消息发送给消费者应用程序。
20. 绑定（Binding）：消息队列和交换之间的一种路由关系。
21. 绑定键（Binding Key）：绑定键，交换机和消息队列的对应关系。
22. 路由键（Routing Key）：一个消息头，交换可以据此决定如何路由这条消息。
23. 持久的（Durable）：服务端重启后仍然存在的服务端资源。
24. 短暂的（Transient）：服务端重启后会被删除或重置的服务端资源。
25. 永久的（Persistent）：服务端存储在可靠硬盘存储设备中的消息，服务端重启后也不会丢失。
26. 非永久的（Non-Persistent）：服务端存储在内存中的消息，服务端重启后可能丢失。
27. 消费者（Consumer）：客户端应用程序，从消息队列请求数据。
28. 生产者（Producer）：客户端应用程序，向交换发布消息。（注：不是发布到队列）
29. 虚拟主机（Virtual Host）：包含交换机、消息队列和关联对象的集合。虚拟主机是一个独立的服务环境，有着相同的认证机制和加密环境。客户端应用程序在登录服务端后选择一个虚拟主机。
30. 主题（Topic）：分发消息，AMQP通过一个或多个类型的交换实现主题。
31. 代理（Broker）：与服务端是一个意思。


## 2 AMQP模型

### 2.1 AMQP模型介绍

![AMQP Model]({{ CDN_PATH }}{{ site.img_url }}/2014091501.png)

中间件服务器：接收消息的数据服务器，该服务器主要做两件事情，一是依据特定条件将消息路由到不同的消费者，二是当消费者没有能力接收消息时将消息缓存到内存或磁盘上。

AMQP通过两个角色来实现中间件服务器的功能：

1. 交换机：接收来自生产者的消息，并将消息路由到消息队列。
2. 消息队列：存储消息和转发消息给消费者应用程序。

连接交换机和消息队列的接口是“绑定”，将在2.5节描述。

AMQP模型有如下三点优势：

1. 可以创建任意的交换机和消息队列类型。
2. 通过连接交换机和消息队列，可以创建各种消息进程系统。
3. 通过约定可以完全控制AMQP模型。

#### 2.1.1 消息队列

消息队列将消息存储在内存或磁盘上，并且按序投递这些消息给一个或多个消费者应用程序。消息队列是一个消息存储和分发实体。每个消息队列都是完全独立的。

消息队列有不同的属性，如：

* 私有的或共享的
* 持久的或短暂的
* 永久的或临时的

通过设置不同的属性，可以使用消息队列实现各种传统的中间件实体，如：

1. 标准的存储转发队列，该队列持有消息，并且基于轮询机制分发消息给订阅者。存储转发队列通常是持久的，并且是多个订阅者之间共享的。
2. 临时应答队列，该队列持有消息，并且将消息转发给一个特定的消费者。应答队列通常是临时的，并且是某一订阅者私有的。
3. 发布/订阅型的订阅队列，该队列持有来自各种“已订阅”源的消息，并且将消息转发给一个特定的消费者。订阅队列通常是临时的，并且是一个消费者私有的。（？怎么和常见的发布/订阅模型不一样啊）

上面三种队列模型只是设置队列不同属性的例子，还可以定义其他模型。

#### 2.1.2 交换机（Exchange）

交换机从生产者应用程序接收消息，然后基于之前设定的条件将消息路由到消息队列。之前设定的条件就是“绑定”。交换机是一个匹配和路由引擎。交换机检查消息，根据句绑定表，决定怎样转发消息到消息队列。交换机不存储消息。

术语“交换机”过去即表示一种算法，也表示该算法的实例。因此，更准确的说法是“交换机类型”和“交换机实例”。

#### 2.1.3 路由键（Routing Key）

一般情况下，交换机检查消息的如下属性：消息头、正文内容和其他源的数据，通过这些属性来决定怎样路由消息。

一般来说，交换机检查一个关键字段：routing key(路由键)，路由键是一个虚拟地址，交换机通过该虚拟地址决定怎样路由消息。

* 对于point-to-point路由，路由键就是消息队列的名字。
* 对于topic pub-sub路由，路由键就是主题层次结构的值（？）。

#### 2.1.4 与Email做比较

1. AMQP消息与email消息类似。
2. 消息队列与邮箱类似。
3. 消费者就像是一个邮件客户端，获取和删除邮件。
4. 交换机就像是一个MTA（邮件转发代理 mail transfer agent），检查邮件，基于路由键和表决定将邮件发送给一个或多个邮箱。
5. 路由键与邮件的To、Cc或Bcc地址类似。
6. 每一个交换机实例就像是一个单独的MTA进程，负责一些电子邮件子域，或者处理一类特殊的邮件。
7. 绑定就像是一个MTA路由表。

#### 2.1.5 消息流

下图展示了消息经由AMQP服务器的流程。

![Message Flow]({{ CDN_PATH }}{{ site.img_url }}/2014091601.png)

##### 2.1.5.1 消息生命周期

AMQP消息由头部和主体构成，头部包含一系列属性，主体对于AMQP透明。

*产生新消息*

生产者应用程序使用客户端API生成新消息。生产者将数据放在消息主体，设置消息属性。生产者给消息打上标签（可以理解为一个虚拟地址，常常是路由键）。之后生产者将消息发送给服务器的交换机。

*路由消息*

当消息到达服务器的交换机，交换机将消息路由到一系列在服务器上存在的消息队列。如果消息不可以路由，交换机可能立即丢弃该消息、拒绝该消息或是依据生产者的请求行为路由给其它交换机。

*消息在消息队列中*

一条消息可以在多个队列中存在。AMQP服务器有可能对这个消息做不同的处理，如复制消息，引用计数等。它们相互之间不会有联系。当一个消息路由到多个消息队列中，消息在各个队列中是完全一样的，也就是说没有一个唯一标识符去区分这些拷贝的消息。

*下发消息*

当消息到达消息队列，消息队列会立即尝试通过AMQP将消息传递给消费者应用程序。如果下发失败，消息队列将存储消息（依据生产者的设置将消息存在内存或磁盘中），并等待订阅者准备好消费消息。

当消息队列可以投递消息给订阅者，消息队列从内部缓存中移除该消息。移除消息可以立即发生，也可以在订阅者成功处理和明确接收消息后发生。订阅者决定什么时候消息被接收了。订阅者可以回滚消息到队列，或者拒绝接收消息。

> 发布消息和订阅都是“事务”的。

##### 2.1.5.2 生产者视角

所有消息都发送给交换机，检查消息、路由消息等对发送者都是透明的。

##### 2.1.5.3 消费者视角

1. 创建或销毁消息队列。
2. 通过设置绑定规则，定义消息进入消息队列的方式。
3. 通过选择不同的交换机来完全改变路由语义。

##### 默认消息流

1. 为消息生产者提供了默认的交换机。
2. 为消息队列提供了默认的绑定，该绑定通过匹配路由键和消息队列名来路由消息。

默认的绑定让生产者将消息直接发送给消息队列。

### 2.2 虚拟机

一个虚拟机由它自己的名字空间、一组交换机、消息队列和所有相关的对象组成。每一个连接（connection）必须和一个虚拟机关联。

客户端在身份认证之后将选择一个虚拟机。因此服务器上的各虚拟机的身份认证方式应该是共享的。

一个连接（connection）的所有通道（channel）在同一个虚拟机上工作。

协议不提供创建或配置虚拟机的机制。

### 2.3 交换机

交换机是虚拟机中的消息路由代理。一个交换机实例（通常称作“一个交换机”）接收消息和路由信息（主要依据路由键），将消息传给消息队列，或者传递给一个插件定义的内部服务。

应用可以依据自己的权限创建、共享、使用和销毁交换机实例。

交换机可能是持久的，短暂的或自动删除的。持久的交换机直到其被删除前一直存在。短暂型的交换机直到服务器关闭前一直存在。自动删除型的交换机当不在使用时就不再存在。

#### 2.3.1 交换机的类型

最重要的两种交换机类型：

1. the direct exchange type，通过绑定键和路由键之间的精确匹配来路由。
2. the topic exchange type，通过绑定键和路由键之间的模式匹配来路由。

需要注意的是：

1. 默认交换机是direct exchange，（见2.1.5.4节）
2. 服务器在启动时会使用众所周知的名字创建一个direct exchange和topic exchange。

##### 2.3.1.1 The Direct Exchange Type（直连交换机类型）

直连交换机类型通过精确匹配消息的路由键，将消息路由到零个或多个消息队列中，绑定键用来绑定队列和交换机。这种类型可以用来构造传统的点对点队列消息模型。

直连交换机类型的工作方式如下：

1. 一个消息队列使用绑定键绑定到一个交换机上，绑定键为K。
2. 一个生产者发送消息给交换机，消息包含了路由键，路由键为R。
3. 消息会传递给所有的与交换机绑定的队列，只要满足K=R。

服务器必须实现直连交换机类型，必须在每个虚拟机中预先声明至少两个直连交换机：一个命名为“amq.direct”，另一个没有公共名字（服务器把它当作默认交换机）。

消息队列绑定到交换机的绑定键可以使用任意的值，不过一般都是用消息队列的名字作为绑定键。

特别需要注意的是，所有的消息队列都必须使用消息队列的名字作为绑定键绑定到无名交换机上（即默认交换机）。

##### 2.3.1.2 The Fanout Exchange Type

fanout交换机类型将消息路由到所有的绑定队列，忽略消息的路由键。

fanout交换机类型的工作方式如下：

1. 一个消息队列不带参数绑定到交换机。
2. 一个生产者发送消息给交换机。
3. 交换机无条件的将消息传递给所有绑定到本交换机的消息队列。

服务器必须实现fanout交换机类型，必须在每个虚拟机中至少预定义一个fanout交换机类型，并命名为“amq.fanout”。

##### 2.3.1.3 The Topic Exchange Type

主题交换机类型基于绑定键和消息的路由键的模式匹配来将消息路由到绑定的队列。这种交换机类型常用来实现发布/订阅范式，通过使用主题名字空间作为寻址模式，基于部分或全部匹配主题模式，来选择和投递消息给多个消费者。

主题交换机类型工作方式如下：

1. 一个消息队列使用绑定键绑定到一个交换机上，绑定键为K。
2. 一个生产者发送消息给交换机，消息包含了路由键，路由键为R。
3. 消息会发送给所有K和R相匹配的消息队列。

绑定键是由零个或多个标记构成，每个标记由字符'.'分隔。标记支持如下通配符：

* `*` 匹配单个单词
* `#` 匹配零个或多个单词

例如，绑定键`*.stock.#`匹配路由键`usd.stock`和`eur.stock.db`，但不匹配`stock.nasdaq`。

这个交换机类型是可选的。

服务器应该实现主题交换机，每个虚拟机都必须预定义至少一个主题交换机，命名为“amq.topic”。

##### 2.3.1.4 The Headers Exchange Type

##### 2.3.1.5 The System Exchange Type

##### 2.3.1.6 由实现定义的交换机类型

#### 2.3.2 交换机的生命周期

每个AMQP服务器会预先建立一系列交换机，这些交换机在服务器启动时即存在并且不能被销毁。

AMQP应用程序也会创建（其实是declare）自己的交换机，当这些交换机工作完成后即可销毁。

### 2.4 消息队列

一个消息队列是一个命名的缓冲区，消息队列为一系列消费者应用程序持有消息。应用程序可以依据其权限创建、分享、使用和销毁消息队列。

消息队列提供一个受限的FIFO策略。来自一个指定生产者的同等优先级的消息在投递给一个指定消费者时，将尽量以消息在队列中的顺序投递。但是在初次投递没有消费消息而再次投递时，可能不会按顺序投递。

消息队列可能是永久的、短暂的或自动删除的。短暂型的消息队列会在服务器关闭时被销毁。自动删除型的消息队列会在该队列不再使用时被销毁。任何类型的队列都可能被用户（客户端）删除，只要该客户拥有删除的权限。

消息队列将消息保存在内存、磁盘或两者的组合中。

消息队列在虚拟机内部。

队列的名字必须由1到255个字符组成。第一个字符只能是如下字符中的：

* a-z
* A-Z
* 0-9
* 下划线`_`

剩下的字符必须是合法的UTF-8字符。

消息队列保存消息并分发消息给一个或多个订阅的客户端。

消息队列跟踪收到的消息。消息在出队时必须被捕获。通过捕获可以预防多客户端同时消费相同的消息的情况出现。同时，多个消费者在一个队列，可以安全地实现负载均衡消费消息。

队列中的消息可能发送给多个客户端，如果消息在发布初初次发送时未被捕获。消息队列可能分发未捕获的消息给客户端，为了允许非破坏性的浏览队列内容。

#### 2.4.1 消息队列属性

当一个客户端应用程序创建一个消息队列时，可以设置一些重要属性：

1. 名字 - 应用程序分享消息队列之前需得指定名字。
2. 持久性 - 如果指定，妈妈再也不用担心服务器重启了。
3. 自动删除 - 如果指定，服务器会在所有客户端完成使用后（或稍稍等一会）删除消息队列。

#### 2.4.2 队列的生命周期

主要有两种消息队列生命周期：

1. 持久消息队列，由许多订阅者共享，并独立存在。如，这种消息队列会一直存在并且收集消息，并判断订阅者是否消费这些消息。
2. 临时消息队列，一个订阅者私有的，与该订阅者绑定。当一个订阅者被取消，该消息队列会被删除。

下图展示了临时消息队列的创建和删除：

![Tempory message queues]({{ CDN_PATH }}{{ site.img_url }}/2014091701.png)

### 2.5 绑定

绑定是消息队列与交换机之间的一种关系。绑定指定一种路由关系，告诉交换机应该把消息路由到哪个队列中。

绑定的生命周期取决于消息队列和交换机，当消息队列或交换机被销毁，对应的绑定也就被销毁。

绑定是由发送给交换机的命令创建的。类似的语法如下：

    Exchange.Bind <exchange> To <queue> WHERE <condition>

#### 2.5.1 构建一个共享队列

共享队列是一个典型的点对点中间件队列。可以使用默认的交换机和绑定构建。假设消息队列的名字为“app.svc01”。创建共享队列的伪代码如下：

    Queue.Declare
        queue=app.svc01
        exclusive=FALSE

可能有许多消费者订阅这个共享队列。为了从这个共享队列消费，每个消费者需执行如下伪代码：

    Message.Subscribe
        queue=app.svc01

向该共享队列发消息，每个生产者使用默认交换机发送消息：

    Message.Transfer
        routing_key=app.svc01

> 消息队列绑定到默认交换机使用的路由键为消息队列名

#### 2.5.2 构建一个应答队列

应答队列通常是临时的、私有的，由一个订阅者独占。应答队列使用与标准队列相同的匹配语法，所以仍然可以使用默认交换机。为了预防不同客户端生成的临时队列的名字空间冲突，推荐客户端在队列名字中包含UUID（通用唯一标识符）或是其它唯一标识符。

下面是一个创建应答队列的伪代码：

    Queue.Declare
        queue=tmp.550e8400-e29b-41d4-a716-446655440000
        exclusive=TRUE
        auto_delete=TRUE

为了向应答队列发消息，生产者向默认交换机发送消息：

    Message.Transfer
        routing_key=tmp.550e8400-e29b-41d4-a716-446655440000

#### 2.5.3 构建一个发布/订阅队列

在传统中间件，术语“订阅”泛指两种不同的概念：匹配消息的语义集和拥有匹配信息的临时队列。AMQP使用绑定和消息队列来区分这两个概念。

订阅队列与命名队列或应答队列的区别在于订阅队列名与路由无关。与路由键字段的1对1匹配相比较，发布队列的路由更加抽象。

在下面会列举一个构建发布/订阅队列的例子，需要的交换机类型是主题交换机类型，其通配符为`STOCK.USD.*`，相对应的路由键为`STOCK.USD.NYSE`。

不能使用默认的交换机和绑定，因为它们不支持主题类型的路由。因此自己创建一个绑定。下面是创建绑定和发布/订阅队列的伪代码：

    Queue.Declare
        queue=tmp.2
        auto_delete=TRUE

    Exchange.Bind
        exchange=amp.topic
        TO
        queue=tmp.2
        WHERE routing_key=STOCK.USD.*

上面实现的功能是创建一个名为“tmp.2”的队列，并将其绑定到"amp.topic"交换机。

客户端必须订阅该队列才能收到消息：

    Message.Subscribe
        queue=tmp.2

当发布消息时，生产者要做的类似如下：

    Message.Transfer
        exchange=amp.topic
        routing_key=STOCK.USD.IBM

主题交换机将会匹配`STOCK.USD.IBM`到`STOCK.USD.*`，即会将消息发到队列“tmp.2”。

### 2.6 消息

消息是路由和排队的原子单元。消息有一个定义了一系列属性的头部，一个透明二进制数据主体。

消息可以是持久的，一个持久消息将安全的存在磁盘上，确保在各种网络失败、服务器宕机或溢出等情况出现时，消息都不会丢失。

消息可以有优先级。在同一个消息队列中，高优先级的消息将在低优先级的消息前面发送。当必须丢弃消息时（快溢出了么？），服务器会先丢弃低优先级的消息。

服务器不会更改消息的主体部分，但是在转发给消费者应用程序之前会经常修改消息头。

#### 2.6.1 消息流控制

流控制用来限制匹配消息的速度。一般情况下，流控制保证控制有多少消息或多少字节的数据会发送给接收点，以保证接收者的资源不会被耗尽。接收者可能是AMQP服务器、接收消息的客户端。

#### 2.6.2 责任迁移？

AMQP支持两种不同的接收模式：

1. 接收应用程序必须对每个或一批消息发送确认接收响应。
2. 一旦消息发送，即认为是被接收了。

### 2.7 订阅

使用术语“订阅”表示如何控制一个特定的客户端应用程序从消息队列接收消息。当一个客户端开始订阅，即在服务器中创建一个订阅实体。当一个客户端取消订阅，即销毁在服务器中的订阅实体。

订阅属于特定的客户端会话，订阅使消息队列异步发送消息给客户端。

### 2.8 事务

AMQP定义了两种事务模型：单阶段提交事务模型和两阶段提交分布式事务模型。单阶段提交的模型的适用单个会话。客户端控制选择会话是否是事务性的，但是一旦一个会话选择为事务性的（通过`tx.select`命令），该会话会一直保持为事务性的直到所在结点被销毁。

如果AMQP客户端在事务范围内发布消息，那么该消息就不能路由到任何队列中直到事务完成。

当事务回滚，客户端的发布命令和接收命令就会被丢弃。在回滚之后，客户端仍然拥有事务范围内的所有投递过的消息（无论消息是否被接收）。如果客户端希望服务器重新处理这些消息，客户端需发出合适的发布命令（？）。

### 2.9 分布式事务

分布式事务支持X-Open XA结构（这是什么结构）。

> XA规范是开发群组关于分布式事务处理（DTP）的规范。规范描述了全局的事务管理器与局部的资源管理器之间的接口。XA规范的目的是允许多个资源（如数据库，应用服务器，消息队列，等等）在同一事务中访问，这样可以使ACID属性跨越应用程序而保持有效。XA使用两阶段提交来保证所有资源同时提交或回滚任何特定的事务。

> XA规范描述了资源管理器要支持事务性访问说必须做的事情。遵守该规范的资源管理器被称为XA compliant。

> 转自[维基百科](http://zh.wikipedia.org/wiki/X/Open_XA)

dtx类用作划分和协调事务。在一个给定的会话中，`dtx.start`和`dtx.end`命令界定AMQP事务的工作范围。dtx类中剩余的命令提供事务的协调和恢复功能。

OMG OTS和JTS/JTA模型依赖于资源管理客户端（RM Client）示例，资源管理客户端实现了XA接口的底层资源，这对于参与全局事务是必要的。资源管理器客户端实体由Rmids认证，Rmids通过xa_switch（来自于C/C++）或XAResource（来自于Java）实现。

如下图所示，事务管理器使用资源管理器客户端（RM Client）的接口划定事务的边界和协调事务的结构。在一个会话中资源管理客户端使用`dtx.start`和`dtx.end`命令界定事务。然后事务会话暴露给应用程序驱动事务，之后可能用来做事务性的发布和消费消息。资源管理客户端使用dtx的协调命令来传输事务的结果和恢复操作。

![transaction]({{ CDN_PATH }}{{ site.img_url }}/2014091702.png)

#### 2.9.1  分布式事务方案

下图列举了一个消息方案，一个应用程序“Application”事务消费一个来自队列Q1（通过使用来自食物管理器TM的事务T1）的消息。已消费的消息为基础，应用程序使用DBMS更新数据库表Tb，为事务T1发布消息到队列Q2。

![transaction]({{ CDN_PATH }}{{ site.img_url }}/2014091703.png)
