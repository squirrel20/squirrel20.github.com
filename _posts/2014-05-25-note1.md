---
layout: post
title: "《UNIX网络编程》卷1：套接字联网API：第12章：IPv4与IPv6的互操作性"
description: "IPv4客户端与IPv6服务器协同工作，IPv6客户端与IPv4服务器协同工作"
category: "读书笔记"
tags: [读书笔记, UNIX网络编程 卷1：套接字联网API]
---
{% include JB/setup %}

> 读完一章就做个记录，养成做读书笔记的习惯应该是不错的。

现在有这样一个问题：基于IPv4的现有应用程序如何与基于IPv6的全新应用程序协同工作，IPv4应用进程和IPv6应用进程如何才能彼此通信？

首先介绍了一个概念，*主机运行着双栈*：意指一个IPv4协议栈和一个IPv6协议栈都运行在主机上。

### IPv4客户与IPv6服务器

双栈主机的一个基本特性是其上的IPv6服务器既能处理IPv4客户，又能处理IPv6客户。这是通过使用*IPv4映射的IPv6地址*实现的。

IPv4的TCP客户和IPv6的TCP服务器通信的步骤如下（IPv6服务器是双栈主机）：

1. IPv6服务器启动后创建一个IPv6的监听套接字，我们假定服务器把通配地址捆绑到该套接字。
2. IPv4客户调用gethostbyname找到服务器主机的一个A记录。服务器主机既有一个A记录，又有一个AAAA记录，因为它同时支持IPv4和IPv6，不过IPv4客户需要的只是一个A记录。
3. 客户调用connect，导致客户主机发送一个IPv4 SYN到服务器主机。
4. 服务器主机接收到这个目的地为IPv6监听套接字的IPv4 SYN，设置一个*标志*指示本连接应使用IPv4映射的IPv6，然后响应以一个IPv4 SYN/ACK。该连接建立后，由accpet返回给服务器的地址就是这个IPv4映射的IPv6地址。
5. 当服务器主机往这个IPv4映射的IPv6地址发送TCP分节时，其IP栈产生目的地址为所映射IPv4地址的IPv4载送数据报。因此，客户和服务器之间的所有通信都使用IPv4的载送数据报。
6. 除非服务器显示检查这个IPv6地址是不是一个IPv4映射的IPv6地址（使用IN6_IS_ADDR_V4MAPPED宏），否则它永远不知道自己是在与一个IPv4客户通信。这个细节由*双协议栈*处理。同样地，IPv4客户也不知道自己是在与一个IPv6服务器通信。

注意，上述情形假设双栈服务器主机既有一个IPv4地址，又有一个IPv6地址。

### IPv6客户与IPv4服务器

1. 一个IPv4服务器在只支持IPv4的一个主机上启动启动后创建一个IPv4的监听套接字。
2. IPv6客户启动后调用getaddrinfo单纯查找IPv6地址（请求AF_INET6地址族，而且在hints结构中设置了AI_V4MAPPED标志）。既然只支持IPv4的那个服务器主机只有A记录，返回给客户的是一个IPv4映射的IPv6地址。
3. IPv6客户在作为函数参数的IPv6套接字地址结构中设置这个IPv4映射的IPv6地址后调用connect。内核检测到这个映射地址后自动发送一个IPv4 SYN到服务器。
4. 服务器响应以一个IPv4 SYN/ACK，连接于是痛过使用IPv4数据报建立。

> 通过*IPv4客户与IPv6服务器*和*IPv6客户与IPv4服务器*中通信步骤可以看出，地址映射发生在网络层，对于传输层其是透明的。当IPv4应用进程和IPv6应用进程彼此通信时，使用IPv4与IPv6之间的地址映射可以达到目的。

### 源代码的可移植性

> 协议无关

1. 去除所有gethostbyname和gethostbyaddr调用，改用getaddrinfo和getnameinfo。这一步使得我们能够不用关心套接字地址的具体结构，只需要用一个指针及大小来指代它。
2. 封装TCP连接和TCP监听，只返回要使用的套接字就可以了。这部分功能可以放在一个函数库里面。
