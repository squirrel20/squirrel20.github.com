---
layout: post
title: "读书笔记（6）：C++ Primer"
description: ""
category: "C++ Primer"
tags: [读书笔记]
---
{% include JB/setup %}

每个C++程序都包含一个或多个函数，而且必须有一个命名为main。函数由执行函数功能的语句序列组成。操作系统通过调用main函数来执行程序，main函数则执行组成自己的语句并返回一个值给操作系统。

C++设计的主要焦点就是使所定义的*类类型*的行为可以像内置内省一样自然。像istream和ostream这样的库类型，都是定义为类的，也就是说，它们严格来说不是语言的一部分。

### 强静态类型

C++是一门静态类型语言，在编译时会作类型检查。

在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，俺么这种类型的对象也就不能执行该操作。

在C++中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。

随着程序和使用的类型越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量钱必须定义变量的类型。

### 变量

变量提供了程序可以操作的有名字的存储区。C++中的每一个变量都由特定的类型，该类型决定了变量的大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。

### 什么是对象

一般而言，对象就是内存中具有类型的区域。说得更具体一点，计算左值表达式就会产生对象。

严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可悲程序改变的数据，用术语值描述只读数据。

比较通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。

### 声明和定义

变量的定义用于为变量分配存储空间，还可以为变量指定初值。在一个程序中，变量有且仅有一次定义。

声明用于向程序声明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用extern关键字声明变量而不定义它。

{% highlight c++ %}
extern int i;		// 声明
extern int i = 0;	// 定义
int i;				// 定义
{% endhighlight %}

> 在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或声明变量。

任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。

### struct关键字

struct和class关键字都可以定义类。

如果使用class关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为private；如果使用struct关键字，那么这些成员都是public。使用class还是struct关键字来定义类，仅仅影响默认的初始化访问级别。

### 容器、迭代器 vs 数组、指针

#### 容器

容器（vector）是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型。

{% highlight c++ %}
#include <vector>
using std:vector;

vector<int>			ivec;
vector<string>		svec;
vector<some_class>	cvec;
{% endhighlight %}

vector不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。

vector对象（以及其他标准库容器对象）的重要属性就在于可以再运行时高效地添加元素。因为vector增长的效率高，在元素值已知的情况下，最好是动态地添加元素。虽然可以对给定元素个数的vector对象预先分配内存，但更有效的方法是先初始化一个空vector对象，然后再动态地增加元素。

#### 迭代器

迭代器是一种检查容器内元素并遍历元素的数据类型。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代C++程序更倾向于适用迭代器而不是下标操作访问容器元素，即使对支持下标操作的vector类型也是这样。

若一种类型支持一组确定的操作（这些操作可用来便利容器内的元素，并访问这些元素的值），我们就称这种类型为迭代器。

各容器类都定义了自己的iterator类型，用于访问容器内的元素。换句话说，每个容器都定义了一个名为iterator的类型，而这种类型支持（概念上的）迭代器的各种操作。

{% highlight c++ %}
vector<int> ivec;

....

for (vector<int>::iterator iter = ivec.begin(); iter != ivec.end(); ++iter)
	*iter = 0;
{% endhighlight %}

若使用const_iterator类型，该类型只能读取容器内的元素，但不能改变其值。

