---
layout: post
title: "读书笔记（6）：C++ Primer"
description: ""
category: "CPlusPlus Primer"
tags: [读书笔记]
---
{% include JB/setup %}

每个C++程序都包含一个或多个函数，而且必须有一个命名为main。函数由执行函数功能的语句序列组成。操作系统通过调用main函数来执行程序，main函数则执行组成自己的语句并返回一个值给操作系统。

C++设计的主要焦点就是使所定义的*类类型*的行为可以像内置内省一样自然。像istream和ostream这样的库类型，都是定义为类的，也就是说，它们严格来说不是语言的一部分。

### 强静态类型

C++是一门静态类型语言，在编译时会作类型检查。

在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，俺么这种类型的对象也就不能执行该操作。

在C++中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。

随着程序和使用的类型越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量钱必须定义变量的类型。

### 变量

变量提供了程序可以操作的有名字的存储区。C++中的每一个变量都由特定的类型，该类型决定了变量的大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。

### 什么是对象

一般而言，对象就是内存中具有类型的区域。说得更具体一点，计算左值表达式就会产生对象。

严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可悲程序改变的数据，用术语值描述只读数据。

比较通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。

### 声明和定义

变量的定义用于为变量分配存储空间，还可以为变量指定初值。在一个程序中，变量有且仅有一次定义。

声明用于向程序声明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用extern关键字声明变量而不定义它。

{% highlight c++ %}
extern int i;		// 声明
extern int i = 0;	// 定义
int i;				// 定义
{% endhighlight %}

> 在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或声明变量。

任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。

### struct关键字

struct和class关键字都可以定义类。

如果使用class关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为private；如果使用struct关键字，那么这些成员都是public。使用class还是struct关键字来定义类，仅仅影响默认的初始化访问级别。

### vector、迭代器 vs 数组、指针

#### vector

容器（vector）是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型。

{% highlight c++ %}
#include <vector>
using std:vector;

vector<int>			ivec;
vector<string>		svec;
vector<some_class>	cvec;
{% endhighlight %}

vector不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。

vector对象（以及其他标准库容器对象）的重要属性就在于可以再运行时高效地添加元素。因为vector增长的效率高，在元素值已知的情况下，最好是动态地添加元素。虽然可以对给定元素个数的vector对象预先分配内存，但更有效的方法是先初始化一个空vector对象，然后再动态地增加元素。

#### 迭代器

迭代器是一种检查容器内元素并遍历元素的数据类型。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代C++程序更倾向于适用迭代器而不是下标操作访问容器元素，即使对支持下标操作的vector类型也是这样。

若一种类型支持一组确定的操作（这些操作可用来便利容器内的元素，并访问这些元素的值），我们就称这种类型为迭代器。

各容器类都定义了自己的iterator类型，用于访问容器内的元素。换句话说，每个容器都定义了一个名为iterator的类型，而这种类型支持（概念上的）迭代器的各种操作。

{% highlight c++ %}
vector<int> ivec;

....

for (vector<int>::iterator iter = ivec.begin(); iter != ivec.end(); ++iter)
	*iter = 0;
{% endhighlight %}

若使用const_iterator类型，该类型只能读取容器内的元素，但不能改变其值。

#### 数组

数组是C++语言中类似于标准库vector类型的内置数据结构。域vector类似，数组也是一种存储单一数据类型对象的容器，其中每个对象都没有单独的名字，而是通过它们在数组中的位置对它们进行访问。

#### 指针

指针式指向某种类型对象的复合数据类型，是用于数组的迭代器：指向数组中的一个元素。

指针用于指向对象。与迭代器一样，指针提供对其指向对象的间接访问，只是指针结构更通用一些。

指针保存的是另一个对象的地址。

#### 数组和vector的区别

数组的长度是固定的，数组一经创建，就不允许添加新的元素。而vector可以动态添加元素。

与vector类型相比，数组的显著缺陷在于：数组的长度是固定的，而且程序员无法知道一个给定数组的长度(如果仅知道数组的首地址)。数组没有获取其容量大小的size操作，也不提供push_back操作在其中添加元素。如果需要更改数组的长度，程序员只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组的空间中去。

与使用标准vector类型的程序相比，依赖于内置数组的程序更容易出错且难于调试。除了程序员自己注意细节，并彻底测试自己的程序之外，没有别的办法可防止数组越界。通过编译并执行的程序仍然存在致命的错误，这并不是不可能的。

数组的性能高于vector。

#### 指针和迭代器的区别

指针可以像迭代器一样用于遍历和检查数组中的元素。

指针用于指向单个对象，而迭代器只能用于访问容器内的元素。

#### 尽量避免使用指针和数组

指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生于繁琐细节相关的错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。

许多有用的程序都可不使用数组或指针实现，现代C++程序采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。

### 指针和引用的比较

1. 引用总是指向某个对象：定义引用时没有初始化是错误的。
2. 赋值行为的差异：给引用赋值修改的该引用所关联的对象的值，而并不是使引用于另一个对象关联。引用一经初始化就始终指向同一个特定对象。