---
layout: post
title: "翻译：最长回文子串Manacher算法"
description: ""
category: ""
tags: []
---
{% include JB/setup %}

> 翻译自：[Longest Palindromic Substring Part II](http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html)

*给定一个字符串S，找到S的最长的回文子串*

*注：*

这是文章[Longest Palindromic Substring](http://leetcode.com/2011/11/longest-palindromic-substring-part-i.html)的第二篇。这篇文章将介绍一种线性时间复杂度求最长回文子串的算法（Manacher算法）。如果要了解更多求最长回文子串的信息，可以看[第一篇](http://leetcode.com/2011/11/longest-palindromic-substring-part-i.html)。

在[第一篇](http://leetcode.com/2011/11/longest-palindromic-substring-part-i.html)中讨论了四中方法求最长回文子串，这些方法的时间复杂度为O(N*N)，常数级的空间复杂度。即将讨论的Manacher算法的时间复杂度和空间复杂度都为O(N)。

*提示：*

如何降低时间复杂度。考虑最坏的情况是回文子串相互重叠。比如，`aaaaaaaaaaaa`和`cabcbabcbabcba`。事实上，我们可以利用回文串的对称性来避免一些不必要的计算。

### O(N)的解决方案（Manacher算法）

首先，我们格式化输入字符串S，在每个字符之间插入字符'#'得到字符串T。稍后将会解释为什么要做这个操作。

例如：S = "abaaba"， T = "#a#b#a#a#b#a#"。

