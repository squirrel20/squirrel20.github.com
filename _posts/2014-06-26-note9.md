---
layout: post
title: "读书笔记（9）：Erlang程序设计（第2版）：第一部分"
description: ""
category: "erlang"
tags: [读书笔记]
---
{% include JB/setup %}

### 并发（concurrent）和并行（parallel）

如果只有一台单核的计算机，是无法再上面运行并行程序的。因为只有一个CPU，而它一次只能做一件事。然后，可以在单核计算机上运行并发程序。计算机在不同的任务之间分享时间，使人产生这些任务是并行运行的错觉。

* *并发程序*是一种用并发编程语言编写的程序。编写并发程序是为了提升性能、可扩展性和容错性。
* *并发编程语言*拥有专门用于编写并发程序的语言结构。这些结构是编程语言的主要部分，在所有操作系统上都有着相同的表现。
* *并行计算机*是一种有多个处理单元（CPU或核心）同时运行的计算机。

要用Erlang编写一个并发程序，必须确定一组用来解决问题的进程。这种确定进程的做法被称为*并发建模*。

> 我们的并发程序是否真的会在并行计算机上并行运行？有时候很难知道。在多核计算机上，操作系统也许会决定关闭一个核心来节能。在云端，某个计算也许会被挂起并转移到一台新机器上。这些情况不在我们的控制范围内。

### spawn函数

spawn是一个Erlang基本函数，它会创建一个并发进程并返回一个进程标识符。spawn可以这样调用：

	spawn(ModName, FuncName, [Arg1, Arg2, ..., ArgN])

当Erlang执行spawn时，它会创建一个新进程（不是操作系统的进程，而是一个由Erlang系统管理的轻量级进程）。当进程创建完毕后，它便开始执行参数所指定的代码。ModName是包含想要执行代码的模块名。FuncName是模块里的函数名，而[Arg1, Arg2, ..., ArgN]是一个列表，包含了想要执行的函数参数。

spawn的返回值是一个进程标识符（PID，Process IDentifier），可以用来与新创建的进程交互。

### 发送消息

在Erlang里，各个进程不共享内存，只能通过发送消息来与其他进程交互。这就是现实世界里的物体行为。其格式为：

	Pid ! Msg

其意思是发送消息Msg到进程Pid。例如：

	Susannah ! {self(), "Hope the dogs don't chase the rabbits"}

其中接收消息的进程ID是Susannah，发送的消息是{self(), "Hope the dogs don't chase the rabbits"}，self()参数表明了发送消息的进程。

### 接收消息

接收消息的语法是：

	receive
		{From, Message} ->
			...
	end

From为发送消息的进程ID，Message为发送的消息。

### 一个文件服务器例子

	afile_server.erl

{% highlight erlang %}
-module(afile_server).
-export([start/1, loop/1]).

start(Dir) -> spawn(afile_server, loop, [Dir]) .

loop(Dir) ->
	receive
		{Client, list_dir} ->
			Client ! {self(), file:list_dir(Dir)};
		{Client, {get_file, File}} ->
			Full = filename:join(Dir, File),
			Client ! {self(), file:read_file(Full)};
		{Client, {put_file, Path, {ok, Content}}} ->
			file:write_file(Path, Content),
			Client ! {self(), {ok, {Path, "upload done!"}}}
	end,
	loop(Dir).
{% endhighlight %}

	afile_client.erl

{% highlight erlang %}
-module(afile_client).
-export([test/0, ls/1, get_file/2, put_file/3]).

test() ->
	Server = afile_server:start("."),
	put_file(Server, "notice.html", "notice2.html").

ls(Server) ->
	Server ! {self(), list_dir},
	receive
		{Server, FileList} ->
			FileList
	end.

get_file(Server, File) ->
	Server ! {self(), {get_file, File}},
	receive
		{Server, Content} ->
			Content
	end.

put_file(Server, FromFile, ToFile) ->
	Server ! {self(), {put_file, ToFile, file:read_file(FromFile)}},
	receive
		{Server, {ok, MSG}} ->
			MSG
	end.
{% endhighlight %}

测试：

	1> c(afile_server).
	{ok,afile_server}
	2> c(afile_client).
	{ok,afile_client}
	3> FileServer = afile_server:start(".").
	<0.43.0>
	4> afile_client:ls(FileServer).
	...

