---
layout: post
title: "《编译原理 第2版》第1章 引论"
description: ""
category: "读书笔记"
tags: [读书笔记,编译原理]
---
{% include JB/setup %}

## 1.1 语言处理器

*编译器*

编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成为一个等价的，用另一种语言（目标语言）编写的程序。编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误。

	源程序 -> 『编译器』 -> 目标程序

一般的过程是，经过预处理（预处理器）的源程序作为输入传递给一个编译器，编译器可能产生一个汇编语言程序作为输出，因为汇编语言比较容易输出和调试。

*目标程序*

如果目标程序是一个可执行的机器语言程序，那么它就可以被用户调用，处理输入并产生输出。

	输入 -> 『目标程序』 -> 输出

*解释器*

从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。

	源程序 + 输入 -> 『解释器』 -> 输出

*编译器和解释器的比较*

在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而解释器的错误诊断通常比编译器更好，因为它逐个语句地执行源程序（？为什么逐个语句执行源程序就能更好诊断出错误呢，是不是因为执行某一语句出错了，那么就可以直接退出，然后得出该语句执行出错）。

*Java语言处理器*

Java语言处理器结合了编译和解释过程。一个Java源程序首先被编译成一个称为字节码（bytecode）的中间表示形式。然后由一个虚拟机对得到的字节码加以解释执行。这样安排的好处之一是在一台机器上编译得到的字节码可以在另一台机器上解释执行。通过网络就可以完成机器之间的迁移。

	（源程序 -> 『翻译器』 -> 中间程序） + 输入 -> 『虚拟机』 -> 输出

*即时编译器*

为了更快地完成输入到输出的处理，有些被称为即时编译器的Java编译器在运行中间程序处理输入的前一刻首先把字节码翻译称成为机器语言，然后再执行程序。

*预处理器*

一个源程序可能被分割成为多个模块，并存放于独立的文件中。把源程序聚合在一起的任务有时会由一个被称为预处理器（preprocessor）的程序独立完成。预处理器还负责把那些称为宏的缩写形式转换为源语言的语句。

	源程序 -> 『预处理器』 -> 经过预处理的源程序

*汇编器*

汇编器将汇编语言程序作为输入，生成可重定位的机器代码。

	目标汇编程序 -> 『汇编器』 -> 可重定位机器代码

*链接器*

大型程序经常被分成多个部分进行编译，因此，可重定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，形成真正的机器上运行的代码。一个文件中的代码可能指向另一个文件中的位置，而链接器（linker）能够解决外部内存地址的问题。

*加载器*

加载器把所有的可执行目标文件放到内存中执行。

	可重定位机器代码 + 库文件/可重定位库文件 -> 『链接器/加载器』 -> 目标机器代码

<!--more-->

## 1.2 一个编译器的结构

编译器：把源程序*映射*为在语义上等价的目标程序。映射的过程由两个部分组成：分析部分和综合部分。

分析（analysis）部分把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后，它使用这个结构来创建该远程的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表（symbol table）的数据结构中。符号表将和中间表示形式一起传送给综合部分。

综合（synthesis）部分根据中间表示和符号表中的信息来构造用户期待的目标程序。

分析部分经常被称为编译器的前端（front end），而综合部分称为后端（back end）。总结下来，源程序到目标程序的过程就是：

	源程序 -> 『分析』 -> 中间表示形式 + 符号表 -> 『综合』 -> 目标程序

一个典型的把编译程序分解成为多个步骤的方式如下：

	字符流 -> 『词法分析器』 -> 符号流 -> 『语法分析』 -> 语法树 -> 『语义分析』 -> 语法树 -> 『中间代码生成器』 -> 中间表示形式 -> 『机器无关代码优化器』 -> 中间表示形式 -> 『代码生成器』 -> 目标机器语言 -> 『机器相关代码优化器』 -> 目标机器语言

其中分析部分可以包括：词法分析器、语法分析、语义分析和中间代码生成器。综合部分可以包括：代码生成器和机器相关代码优化器。机器无关代码优化器是可选的。

### 词法分析（扫描）

词法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素（lexeme）的序列。

对于每个词素，词法分析器产生如下的词法单元（token）作为输出：

	<token-name, attribute-value>

词法单元被传送给语法分析器。其中，第一个分量token-name是一个由语法分析步骤使用的抽象符号，而第二个分量attribute-value指向符号表中关于这个词法单元的条目。该条目的信息会被语义分析和代码生成步骤使用。

#### 一个例子

假设一个源程序包含如下的赋值语句

	position = initial + rate * 60

1. 词素 position，对应的词法单元<id, 1>，其中id是表示标识符（identifier）的抽象符号，而1指向符号表中position对应的条目。一个标识符对应的符号表条目存放该标识符有关的信息，比如它的名字和类型。
2. 词素 =，对应的词法单元<=>。
3. 词素 initial，对应的词法单元<id, 2>，其中2指向initial对应的符号表的条目。
4. 词素 +，对应的词法单元<+>。
5. 词素 rate，对应的词法单元<id, 3>。
6. 词素 *，对应的词法单元<*>。
7. 词素 60，对应的词法单元<60>。（其实应该是<number, 4>）

那么上面的赋值语句对应的词法单元序列为：

	<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>

### 语法分析（解析）

语法分析器使用由词法分析器生成的各词法单元的第一个分量来创建树形的中间表示。

该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法是语法树（syntax tree），树中的每个内部结点表示一个运算，而该结点的子节点表示该运算的分量。

### 语义分析

语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。

语义分析的一个重要部分是类型检查。编译器检查每个运算符是否具有匹配的运算分量。

语义错误就是从这报出的吧。

### 中间代码生成

在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示具有两个重要性质：

1. 易于生成；
2. 能够轻松地翻译为目标机器上的语言。

三地址代码的中间表示形式，这种中间表示由一组类似于汇编语言的指令组成，每个指令具有三个运算分量。每个运算分量都像一个寄存器。对于上面的赋值语句，其三地址代码序列：

	t1 = inttoflaot(60)
	t2 = id3 ＊t1
	t3 = id2 + t2
	id1 = t3

三地址代码遵循如下规则：

1. 每个三地址赋值指令的右部最多只有一个运算符。
2. 编译器应该生成一个临时名字以存放一个三地址指令计算得到的值。
3. 有些三地址指令的运算分量少于三个。

### 代码优化

机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。

对于上面的中间代码，其优化后的结果为：

	t1 = id3 * 60.0
	id1 = id2 + t1

### 代码生成

代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。

如果目标语言是机器代码，那么就必须为程序使用的每个变量选择寄存器或内存位置。然后，中间指令被翻译成为能够完成相同任务的机器指令序列。代码生成的一个至关重要的方面是合理分配寄存器以及存放变量的值。

### 符号表管理

符号表数据结构为每个变量名字创建了一个记录条目。记录的字段就是名字的各个属性。这个数据结构应该允许编译器迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据。