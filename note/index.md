---
layout: page
title: 杂记
header : Note
group: navigation
---
{% include JB/setup %}

<script type="text/javascript">
$(document).ready(function(){
  $(".span14").css("margin", "0");
  $(".span14").css("width", "100%");
});
</script>
<style>

.row li{
	width: 100%;
  list-style: none;
  padding: 20px 10px;
  border-bottom: 1px solid #ccc;
}
.span14{
  width: 100%;
  margin: 0;
}
.span14 ol{
  margin: 0;
  width: 100%;
}
</style>

1. 由UNIX内核提供的基本时间服务是计算自国际标准时间公元1970年1月1日00:00:00以来经过的秒数。[Unix环境高级编程][143][Unix][Linux][C][编程]
2. 在Linux中，账户信息保存在/etc/passwd文件中，格式为：用户名:密码:用户ID:用户所在组ID:用户的个人信息:主目录:shell。[Unix][Linux][系统数据文件]
3. 在Linux中，加密口令保存在/etc/shadow文件中，需要管理员权限才能访问，格式为：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:不活动时间:失效时间:标志。[Unix][Linux][系统数据文件]
4. restrict关键字修饰的指针所指的对象只会通过这个指针访问，用于编译器优化。[C][C99]
5. C程序总是从main函数开始执行，main函数的原型是int main(int argc, char *argv[]);。[C][main]
6. 在C中，有三个函数用于正常终止一个程序：_exit和_Exit立即进入内核；exit则先执行一些清理处理（包括调用执行各终止处理程序，关闭所有标准I/O流等），然后进入内核。[Unix][C][进程终止]
7. Linux内核执行C程序的步骤：exec > 启动例程 > main函数 > 进程终止；启动例程从内核取得命令行参数和环境变量。详细的可概括为：内核 > C启动例程 > main函数( > 用户函数) > exit函数 > 终止处理程序，标准I/O清理程序 > 内核。[C][Unix][Linux][步骤]
8. @Override是伪代码，表示重写（不写也可以），不过写上有如下好处：可以当注释用，方便阅读；编译器可以验证@Override下面的方法名是否是你父类中所有的，如果没有则报错，比如你没写@Override来重载，可是方法名又写错了，这时编译器是可以通过的（它以为这个方法是子类中自己增加的方法）。[http://bbs.csdn.net/topics/300170781#post-301736777][Java][Android][重载][@Override]
9. super.onCreate(); super指示调用父类的方法，此处即为调用父类的onCreate()方法，在Android代码中，子类的onCreate()方法都会调用父类的onCreate()方法以帮助子类完成许多复杂的功能，比如ui绘制等。[Java][Android][super]
10. 在Android的xml布局文件中，使用”@+id/…”作为id值是一种约定，其中”…”表示当前小部件在上下文中唯一的名字。[Android][xml][id][@+id]
11. extern可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。[C]
12. 如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储器就会连续增加，这被称为泄露(leakage)。[C][malloc][free][泄露]
13. 在C中，goto语句是不能跨越函数的，而执行这类跳转功能的是函数setjmp和longjmp。存放在存储器中的变量将具有longjmp时的值，而在CPU和浮点寄存器中的变量则恢复为调用setjmp时的值。因此，如果要编写一个使用非局部跳转的可移植程序，则必须使用volatile属性。[Unix环境高级编程][159][Unix][C][编程]
14. 声明自动变量的函数已经返回后，不能再引用这些自动变量，因为该自动变量保存在栈帧中，而函数返回后，该函数使用的栈空间将被下一个被调用函数的栈帧使用（当前函数已经出栈）。所以若要使用函数中的变量，应在全局存储空间静态地（static或extern）或动态地(alloc函数)为该变量分配空间。[Unix环境高级编程][164][Unix][C][解决了我长期以来的疑惑]
15. 进程标识符ID为0的进程通常是调度进程，常常被称为交换进程，该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。[Unix环境高级编程][171][进程]
16. 进程标识符ID为1的进程通常是init进程，它是一个普通的用户进程，负责在自举内核后启动一个UNIX系统，通常读与系统有关的初始化文件，并将系统引导到一个状态。Init进程绝不会终止，并且以超级用户特权运行。[Unix环境高级编程][171][进程]
17. 由fork创建的新进程被称为止进程[Unix环境高级编程][172][fork]
18. fork函数被调用一次，但返回两次。两次返回的唯一区别是子进程的返回值是0，而父进程的返回值则是新进程的进程ID。[Unix环境高级编程][172][fork]
19. 将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。[Unix环境高级编程][172][fork]
20. Fork使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID（进程ID 0总是由内核交换进程使用，所以一个子进程ID不可能是0）。[Unix环境高级编程][172][fork]
21. 子进程是父进程的副本，子进程获得父进程数据空间、堆和栈的副本，父进程和子进程并不贡献这些部分。父、子进程贡献正文段。（写时复制技术并不是这样实现的）。[Unix环境高级编程][172][fork]
22. 写时复制技术，数据空间、堆和栈由父、子进程贡献，而且内核将它们的访问权限改为只读。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本。[Unix环境高级编程][172][fork]
23. 不带缓冲指的是I/O函数调用内核中的一个系统调用。这些不带缓冲的I/O函数(read,write)不是ISO C的组成部分，但是，它们是POSIX.1和Single UNIX Specification的组成部分。[Unix环境高级编程][47][不带缓冲函数]
24.  Vfork用于创建一个新进程，而该新进程的目的是exec一个新程序（或exit）。它不复制父进程的地址空间，在子进程调用exec或exit之前，它在父进程的空间中运行。[Unix环境高级编程][176][vfork]
25. Vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。（就好比一对情侣吵架了，都等着对方先道歉，然后自己就借坡下驴，死锁啊！）[Unix环境高级编程][176][vfork]
26. Init进程领养：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则将该进程的父进程ID更改为1（init进程的ID）。[Unix环境高级编程][179][init进程领养]
27. 内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。[Unix环境高级编程][179][进程信息]
28. Putty连接linux英文乱码的解决办法：PuTTY Configuration > Windows > Translation > Remote character set: > utf8 [PuTTY][SSH][乱码]
29. #include <sys/wait.h> 中wait、waitpid函数的功能是等待子进程状态改变。调用wait时，调用进程立即阻塞自己，直到子进程状态发生改变；调用waitpid可以设置不阻塞自己。[Unix环境高级编程][179][wait][waitpid][阻塞]
30. 当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。调用exec并不创建新进程，只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。[Unix环境高级编程][188][exec][进程]
31. 解释器文件：文本文件，它以#! pathname [optional-argument]开头；解释器：解释器文件第一行中的pathname指定。[Unix环境高级编程][196][解释器][解释器文件]
32. 每个进程除了有一个进程ID以外，还属于一个进程组，进程组中的所有进程可以接收来自同一终端的各种型号。每个进程组有一个唯一的进程组ID。[Unix环境高级编程][218][进程组]
33. 会话是一个或多个进程组的集合。[会话]
34. 管道(“|”)是一个有标准输入输出链接起来的进程集合，每一个进程的输出(stdout)被直接作为下一个进程的输入(stdin)。[管道][ http://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)]
35. 信号是软件中断。每个信号都有一个名字。这些名字都以三个字符SIG开头。在头文件<signal.h>中，这些信号都被定义为正整数。[Unix环境高级编程][233][信号]
36. 进程的所有信息对该进程的所有线程都是贡献的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。[Unix环境高级编程][288][进程][线程]
37. 对于创建线程，Linux使用clone系统调用来实现pthread_create。clone系统调用创建子进程，这个子进程可以贡献父进程一定数量的执行环境（如文件描述符和内存），这个数量是可配置的。[Unix环境高级编程][291][Linux][线程]
38. oracle查看其他用户的表结构: desc username.tablename; [Oracle][表结构][ http://www.itpub.net/forum.php?mod=redirect&goto=findpost&ptid=977964&pid=10210673]
39. 在css中指定table列的宽度，只需指定th的宽度和table的宽度即可（th的宽度和应该等于table的宽度），不用指定td的宽度。若只指定了th的宽度而未指定table的宽度，此时指定的th的宽度只能理解为min-width。[table][th][td][css][宽度][列]
40. C语言中用#define伪命令定义的对象称为常数，用const限定词定义并初始化的对象称为常量（相对于变量而言）。常数的值在编译时确定，常量的值则在运行时初始化后确定（不过此后只能作为右值使用）。[C][#define][const][Unix网络编程第3版（卷1）][6][译者注]
41. 服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接者调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法，采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法，这个时候调用者和服务绑定在一起，如果客户端要与服务进行通信，那么，onBind()方法必须返回IBinder对象，如果调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法，如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)，如果调用者希望与正在绑定的服务解除绑定，可以调用nbindService()方法，调用 该方法也会导致系统调用服务的onUnbind() --> onDestroy()方法。[Android][Service]
42. 迷途指针也叫悬浮指针、失控指针，是当对一个指针进行delete操作后（这样会释放它所指向的内存）并没有把它设置为空时产生的。在删除指针后不要再使用它。虽然这个指针人然指向原来的内存区域，但是编译器已经把这块内存区域分配给了其他的数据。再次使用这个指针会导致你的程序崩溃。因此当delete一个指针后，要将其变为空指针，即`pointer = 0`。[迷途指针][C][C++]
43. 死代码的英文是dead code。是指在程序操作过程中永远不可能被执行到的代码。通过AQtime覆盖率的分析就可以发现所有的永远不会执行到的代码，但是与程序无关的代码却不一定能够全部发现。消除死代码（DCE）在某些情况下，编译器可以判断出某些代码根本不影响输出，所以编译器会消除这些代码。也可以使用优化作用进行消除。[编译][编译优化][DCE]
44. AQTime和MemProof都是AutomatedQA旗下的产品，AQTime比MemProof提供了更丰富强大的功能。该产品含有完整的性能和调试工具集，能够收集程序运行时关键的性能信息和内存/资源分配信息，并提交概要报告和详细报告，还提供所有的程序优化处理工具，囊括了自定义过滤器、图形化的调用层次结构一直到源代码浏览等内容。AQTime的特色在于它不仅是一款调试工具，还是一款性能优化工具。另外，还支持与基于SCC API的版本控制软件集成使用。[AQTime][编译优化][调试工具][性能优化工具]
45. 强度削弱，就是用一种（或一串）执行时间较短的操作去等价地代替一个操作。例如，乘以2的n次方运算可以用左移来替换（例如，X*8可替换为X<<3），因为在多数机器上，左移运算的速度比乘法运算的速度快。同样，除以2的n次方运算可以用右移来替换（在X大于0时，X / 8可替换为X>>3）。类似的还有：以2的n次方为除数的取模运算可用按位与来替换（例如，X % 8可替换为 X & 7，推而广之，X % N可替换为 X&（N-1））。[强度削弱][http://jpkc.nwpu.edu.cn/jp2005/20/kcwz/wlkc/wlkc/08/8_2_1.htm]
46. 位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。[位域][http://baike.baidu.com/view/1256879.htm]
47. 没有度为1的结点的二叉树称为严格的二叉树（正则的二叉树）。一颗有n个叶子结点的正则二叉树共有2n-1个结点（可以通过边和结点的关系以及结点之间的关系得证）。[二叉树9]
48. 存在父类P和子类C，在Java中，对象是多态的。一个P类变量可以引用C类变量，但是C类变量不能引用P类变量。即程序中出现超类对象的任何地方都可以用子类对象置换。[多态][Java]
49. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用引用对象的实际类型最合适的那个类的方法。[动态绑定][Java]
50. 把函数体与函数调用相联系称为*捆绑(binding)*。当捆绑在程序运行之前（由编译器和链接器）完成时，这称为*早捆绑(early binding)*。C编译只有一种函数调用方式，就是早捆绑。与之相对的是*晚捆绑(late binding)*，也称为*动态捆绑(dynamic binding)*或*运行时捆绑(runtime binding)*，这意味着捆绑根据对象的类型，发生在运行时。对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用virtual关键字。晚捆绑只对virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生。[捆绑][早捆绑][晚捆绑][虚函数][C][C++]
51. 内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。[内存泄露]
52. 可能很多.Net的用户（甚至包括一些dot Net开发者）对Net的内存泄露不是很了解，甚至会说.Net不存在内存泄露，因为“不是有GC机制吗？----”恩，是有这么回事，它可以让你在通常应用中不用考虑令人头疼的资源释放问题，但很遗憾的是这个机制不保证你开发的程序就不存在内存泄露。甚至可以说，dot Net中内存泄露是很常见的。这是因为： 一方面，GC机制本身的缺陷造成的；另一方面，Net中托管资源和非托管资源的处理是有差异的，托管资源的处理是由GC自动执行的（执行时机是不可预知的），而非托管资源 （占少部分，比如文件操作，网络连接等）必须显式地释放，否则就可能造成泄露。综合起来说的话，由于托管资源在Net中占大多数，通常不做显式的资源释放是可以的，不会造成明显的资源泄露，而非托管资源则不然，是发生问题的主战场，是最需要注意的地方。 另外，很多情况下，衰老测试主要关注的是有没有内存泄露的发生，而对其他泄露的重视次之。这是因为，内存跟其他资源是正相关的，也就是说没有内存泄露的发生，其他泄露的发生概率也较小，其根本原因在于几乎所有的资源最后都会在内存上有所反应。[内存泄露][.net内存泄露]
53. 未引用对象可以被垃圾回收机制回收，而被引用对象不能被垃圾回收机制回收。未引用对象当然是没有使用的，因为没有其他对象引用了它。然而未使用对象并不都是未引用的。某些未使用的对象仍然被其他地方引用！这就是内存泄漏起因。[Java内存泄露][http://www.spasvo.com/news/html/20131029103530.html]