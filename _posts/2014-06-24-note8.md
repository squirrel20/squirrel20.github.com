---
layout: post
title: "读书笔记（8）：Erlang程序设计"
description: ""
category: "读书笔记"
tags: [读书笔记, Erlang程序设计, Erlang]
---
{% include JB/setup %}

### 学习Erlang的理由

* 希望编写能在多核计算机上运行更快的程序。
* 希望编写不停机即可修改的可容错性程序。
* 希望尝试传闻中的“函数式语言”是否切实可行。
* 希望使用一种语言，它既在大规模工业产品中经过实战检验，又不乏优秀的类库与活跃的社区。
* 不希望在冗长繁琐的代码中消费时间。

### 变量是变量还是不是变量

* 变量必须以大写字母开头。
* 变量是单一赋值变量。

#### 单一赋值变量

Erlang变量是单一赋值变量。单一赋值变量的值只能一次性地给定。一个变量一旦被赋了值，你想再次改变它，就会得到一个错误。一个变量如果含有一个被赋予的值，就称为*绑定变量*，否则，则称为*自由变量*。

Erlang里面的变量仅是对值的一个引用，就具体实现而言，一个绑定变量就是一个指针，这个指针指向存放那个值的存储区。而那个值是无法改变的。

用术语来说，我们把可修改的内存区域称为可变状态（mutable state）。Erlang是一个函数式语言，不存在可变状态。Erlang没有可变状态，也就没有共享内存，更没有锁，这一切都有利于并行化程序的编写。

#### 变量的赋值和变量的模式匹配

在大多数的语言中，=都表示赋值语句。然而，在Erlang中，=表示一个模式匹配操作。

`Lhs=Rhs`实际上是这样一个过程，对Rhs求值，然后将结果与Lhs进行模式匹配。

### 原子

在Erlang中，原子用来表示不同的*非数字*常量值。

Erlang中的原子是全局有效的，而且无需使用宏定义或者包含文件。

原子是一串以小写字母开头，后跟数字、字母、下划线（_）或邮件符号（@）的字符。如red、cat、joe@somehost以及a_long_name等。

使用单引号引起来的字符也是原子。这就使得原子可以用大写字母作为开头或者包含非数字字符。如'Monday'、'+'、‘an spaces’等。

*一个原子的值就是原子本身。*

### 模块

模块是Erlang中代码的基本单元，我们编写的所有函数都存于模块之中。模块文件通常存放在以.erl为扩展名的文件中。

要运行一个模块，首先需要编译它，编译成功之后的模块文件其扩展名是.beam。

一个模块的结构如下：

* 模块中存放了多个函数；
* 函数由多个子句构成，子句间以分号分割，最后一条子句的后面以句点作为结束符；
* 一个子句都有一个函数头和一个函数体；
* 函数头由函数名和随后的以括号括起来的模式组成；
* 函数体则由一系列表达式组成。

下面的代码创建了一个模块geometry，模块中创建了一个函数area，函数area由两个子句构成，两个子句分别用来求长方形和圆的面积。

{% highlight erlang %}
% geometry.erl

-module(geometry).
-export([area/1]).

% 函数开始
% 第一个子句
% 函数头 -> 函数体
area({rectangle, Width, Ht})	-> Width * Ht;	
% 第二个子句
area({circle, R})				-> 3.14159 * R * R.
% 函数结束
{% endhighlight %}

在shell中编译并调用函数。

	1> c(geometry).
	{ok,geometry}
	2> geometry:area({rectangle, 10, 5}).
	50
	3> geometry:area({circle, 1.4}).
	6.15752

在调用函数时，如果函数头中的模式与调用参数匹配成功的话，其对应的表达式就会进行运算。模式将按照它们出现在函数定义中的先后顺序进行匹配。

在上面的调用中，`geometry:area({rectangle, 10, 5}).`将匹配子句`area({rectangle, Width, Ht}) -> Width * Ht;`。子句返回函数体`Width * Ht`的计算结果，因此得到的结果为50。

> 无处不在的模式匹配

