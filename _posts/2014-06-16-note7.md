---
layout: post
title: "读书笔记（7）：C++ Primer 第二部分"
description: ""
category: "CPlusPlus Primer"
tags: [读书笔记]
---
{% include JB/setup %}

### 顺序容器 （P404）

将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是*顺序容器*。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器的次序决定。

标准库定义了三种顺序容器类型：vector、list和deque（双端队列）。

容器元素类型必须满足以下两个约束：

* 元素类型必须支持赋值运算。
* 元素类型的对象必须可以赋值。

引用类型和IO标准库类型不能作为容器的元素。

#### 容器的容器

因为容器受容器元素类型约束，所以可定义元素是容器类型的容器。

{% highlight c++ %}
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
	vector<string> s1;
	vector< vector<string> > lines;
	s1.push_back("hello");
	lines.push_back(s1);

	cout << lines[0][0] << endl;
	return 0;
}
{% endhighlight %}

### 容器的迭代器 （P414）

C++语言使用一对迭代器标记迭代器范围，这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置。

*左闭合区间 [first, end)*

表示范围从first开始，到last结束，但不包括last。迭代器last可以等于first，或者指向first标记的元素后面的某个元素，但绝对不能指向first标记的元素前面的元素。

*使用左闭合区间的编程意义*

因为左闭合区间有两个方便使用的性质，所以标准库使用此种区间。假设first和last标记了一个有效的迭代器范围，于是：

1. 当first与last相等时，迭代器范围为空;
2. 当first与last不相等时，迭代器范围内至少有一个元素，而且first指向该区间中的第一个元素。此外，通过若干次自增运算可以使first的值不断增大，知道first==last为止。

这两个性质意味着程序员可以安全地编写如下的循环，通过测试迭代器处理一段元素：

{% highlight c++ %}
while (first != last) {
	++first;
}
{% endhighlight %}

假设first和last标记了一段有效的迭代器范围，于是我们知道要么first==last，这是退出循环的情况；要么该区间非空，first指向其第一个元素。因为while循环条件处理了空区间情况，所以对此无需再特别处理。当迭代器范围非空时，循环至少执行一次。由于循环体每次循环就给first加1,因此循环必定会终止。而且在循环内可确保*first是安全的：它必然指向first和last之间非空区间的某个特定元素。

> first < last 不也可以么 ？ 

### 容器的比较 （P425）

容器的比较是基于容器内元素的比较。容器的比较使用了元素类型定义的同一个关系操作符，如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。容器的比较原则：

* 如果两个容器具有相同的长度而且所有元素相等，那么着两个容器就相等；否则，它们就不相等。
* 如果两个容器的长度不相同，但比较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小雨另一个容器。
* 如果不满足上面的2条规则，则它们的比较结果取决于所比较的第一个不相等的元素。

<!--more-->

### 容器定义的类型别名

|size_type|无符号整形，足以存储此类容器类型的最大可能容器长度（容器最大长度可能大于unsigned long long所能容纳的长度）|
|iterator|此容器类型的迭代器类型|
|const_iterator|元素的只读迭代器类型|
|reverse_iterator|按逆序寻址元素的迭代器|
|const_reverse_iterator|元素的只读逆序迭代器|
|difference_type|足够存储两个迭代器差值的有符号整形，可为负数|
|value_type|元素类型|
|reference|元素的左值类型，是value_type&的同义词|
|const_reference|元素的常量左值类型，等效于const value_type&|

### 容器的成员函数

|c.begin()			|返回一个迭代器，它指向容器c的第一个元素|
|c.end()			|返回一个迭代器，它指向容器c的最后一个元素的下一位置|
|c.rbegin()			|返回一个逆序迭代器，它指向容器c的最后一个元素|
|c.rend()			|返回一个逆序迭代器，它指向容器c的第一个元素前面的位置|
|c.push_back(t)		|在容器c的尾部添加值为t的元素。返回void类型|
|c.push_front(t)	|在容器c的前端添加值为t的元素。返回void类型。只适用于list和deque容器类型|
|c.insert(p,t)		|在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器|
|c.insert(p,n,t)	|在迭代器p所指向的元素前面插入n个值为t的新元素。返回void类型|
|c.insert(p,b,e)	|在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void类型|
|c.size()			|返回容器c中的元素个数。返回类型为c::size_type|
|c.max_size()		|返回容器c可容纳的最多元素个数，返回类型为c::size_type|
|c.empty()			|返回标记容器大小是否为0的布尔值|
|c.resize(n)		|调整容器c的长度大小，使其能容纳n个元素，如果n<c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素|
|c.resize(n,t)		|调整容器c的长度大小，使其能容纳n个元素。所有新添加的元素值都为t|
|c.back()			|返回容器c的最后一个元素的引用。如果c为空，则该操作未定义|
|c.front()			|返回容器c的第一个元素的引用。如果c为空，则该操作未定义|
|c[n]				|返回下标为n的元素的引用，如果n<0或n>=c.size()，则该操作未定义。只适用于vector和deque容器|
|c.at(n)			|返回下标为n的元素的引用。如果下标越界，则该操作未定义。只适用于vector和deque容器|
|c.erase(p)			|删除迭代器p所指向的元素。返回一个迭代器，它指向被删除元素后面的元素。如果p指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一个位置。如果p本身就是指向超出末端的下一位置的迭代器，则该函数未定义|
|c.erase(p,e)		|删除迭代器b和e所标记的范围内所有的元素|
|c.clear()			|删除容器c内的所有元素。返回void|
|c.pop_back()		|删除容器c的最后一个元素。返回void。如果c为空容器，则该函数未定义|
|c.pop_front()		|删除容器c的第一个元素。返回void。如果c为空容器，则该函数未定义。只适用于list或deque容器|
|c1 = c2			|删除容器c1的所有元素，然后将c2的元素复制给c1。c1和c2的类型（包括容器类型和元素类型）必须相同|
|c1.swap(c2)		|交换内容：调用完该函数后，c1中存放的是c2原来的元素，c2中存放的则是c1原来的元素。c1和c2的类型必须相同。该函数的执行速度通常要比将c2复制到c1的操作快。因为元素没有复制，只是元素所在的容器变了|
|c.assign(b, e)		|重新设置c的元素：将迭代器b和e标记的范围内所有的元素复制到c中。b和e必须不是指向c中元素的迭代器|
|c.assign(n, t)		|将容器c重新设置为存储n个值为t的元素|