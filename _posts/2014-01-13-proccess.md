---
layout: post
title: "进程"
description: ""
category: "linux"
tags: [linux]
---
{% include JB/setup %}

>进程：一个其中运行着一个或多个线程的地址空间和这些线程所需要的系统资源。

当我们在一个现代操作系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。我们的程序好像是独占地使用处理器和存储器。处理器就好像是无间断地一条接一条地执行程序中的指令。最后，我们程序中的代码和数据好像是系统存储器中唯一的对象。

这些假象都是通过进程的概念提供给我们的。*一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。*从这可以看出进程和程序之间的区别是很微妙的，程序只是用适当形式描述的算法。

进程的经典定义就是*一个执行中的程序的实例*。系统中的每个程序都是运行在某个进程的上下文中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，外壳就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。

进程提供给应用程序的关键抽象：

* 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占使用处理器。
* 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。

<!--more-->

## 创建进程


有4种主要事件导致进程的创建：

1). 系统初始化

> 启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户交互并且替它们完成工作的进程。另外就是后台进程（守护进程），这些进程与特定的用户没有关系，只具有某些专门的功能。

2). 执行了创建进程的系统调用

> 一个正在运行的进程发出系统调用，以便创建一个或多个新进程协助其工作。

3). 用户请求创建一个新进程

> 在交互式系统中，键入一个命令或者点击一个图标就可以启动一个程序。这两个动作的任何一个都会开始一个新的进程，并在其中运行所选择的程序。

4). 一个批处理作业的初始化

> 仅在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。

从技术上看，在这4种情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以时一个运行的用户进程，一个由键盘或鼠标启动的系统进程或者一个批处理管理进程。这个进程所做的工作时，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序。

### fork

在unix系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。通常，子进程接着执行execve或一个类似的系统调用，以修改其存储映像并运行一个新的程序。例如，当一个用户在shell中键入命令sort时，shell就创建一个子进程，然后，这个子进程执行sort。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许进程处理其文件描述符，这样可以完成对标准输入、标准输出和标准出错的重定向。

{% highlight c %}
#include <unistd.h>
pid_t fork(void);
{% endhighlight %}

// 返回值：子进程中返回0，父进程中返回子进程ID，出错返回-1

由fork创建的新进程被称为子进程。fork函数被调用一次，但返回两次。两次返回的唯一区别是子进程的返回值是0，而父进程的返回值则时新子进程的进程ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。fork使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得父进程的进程ID（进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0）。

子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父、子进程并不共享这些存储空间部分（这些空间是可写的）。父、子进程共享正文段（正文段只可读）。同时要注意副本还会复制缓冲区，所以在使用带缓冲函数时要注意到这一点。

由于fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统中的一“页”。


下面是一个fork程序的示例。

{% highlight c %}
#include <unistd.h>
#include <stdio.h>
int main(void){
    pid_t pid;
    if((pid = fork()) < 0){
        fprintf(stderr, "fork error");
    }
    else if(pid == 0){
        // child
    }
    else{
        // parent
    }
}
{% endhighlight %}

fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父、子进程的每个相同的打开描述符共享一个文件表项。这种共享文件的方式使父、子进程对统一文件使用了一个文件偏移量。在fork之后处理文件描述符有两种常见的情况：

1) 父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已执行了相应的更新。

2) 父、子进程各自执行不同的程序段。在这种情况下，在fork之后，父、子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程中经常使用的。

使fork失败的两个主要原因是：系统中已经有太多的进程，或者该实际用户ID的进程总数超过了系统限制。CHILD_MAX规定了每个实际用户ID在任一时刻可具有的最大进程树。

fork有下面两种用法：

1. 一个父进程希望复制自己，使父、子进程同时执行不同的代码断。这在网络服务进程中是常见的，父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求到达。
2. 一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从fork返回后立即调用exec。


### exec

fork函数创建子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。

....................未完，待续

### 进程标识符 PID

每个进程都会被分配一个唯一非负的数字编号，我们称之为*进程标识符*或PID。它通常是一个取值范围从2到32768的正整数。当进程被启动时，系统将按顺序选择下一个未被使用的数字作为它的PID，当数字已经回饶一圈时，新的PID重新从2开始。

虽然PID是唯一的，但是可以重用。当一个进程终止后，其进程ID就可以再次使用了。大多数UNIX系统实现延迟重用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。

ID为0的进程通常是调度进程，常常称为*交换进程(swaper)*。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为*系统进程*。

ID为1的进程通常是init进程，在自举过程结束时由内核调用。init通常读与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及/etc/init.d/中的文件），并将系统引导到一个状态（例如多用户）。init进程决不会终止。它是一个普通用的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。

常用标识符获取函数

{% highlight c %}
#include <unistd.h>
pid_t getpid(void);		// 返回调用进程的ID
pid_t getppid(void);		// 返回调用进程的父进程ID
uid_t getuid(void);		// 返回调用进程的实际用户ID
uid_t geteuid(void);		// 返回调用进程的有效用户ID
gid_t getgid(void);		// 返回调用进程的实际组ID
gid_t getegid(void);		// 返回调用进程的有效组ID
{% endhighlight %}