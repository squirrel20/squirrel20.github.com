---
layout: post
title: "《算法导论 第2版》 第32章 字符串匹配"
description: ""
category: "读书笔记"
tags: [读书笔记, KMP]
---
{% include JB/setup %}

通俗的讲，字符串匹配就是在一个较长的字符串中查找一个指定的字符串。形式化定义如下。

假设文本是一个长度为n的数组T[1..n]，模式是一个长度为m<=n的数组P[1..m]。如果0<=s<=n-m，并且T[s+1..s+m]=P[1..m]（即对1<=j<=m，有T[s+j]=P[j]），则说模式P在文本T中出现且位移为s。

如果P在T中出现且位移为s，则称s是一个有效位移，否则称s为无效位移。这样一来，字符串匹配问题就变成一个在指定的文本T中，找出某指定模式P出现的所有有效位移的问题。

关于字符串匹配，下面列出了四个算法：

|算法|预处理时间|匹配时间|
|----|----------|--------|
|朴素算法|0|O((n-m+1)m)|
|Rabin-Karp|O(m)|O((n-m+1)m)|
|有限自动机算法|O(mE)|O(n)|
|KMP|O(m)|O(n)|

<!--more-->

## 1 朴素的字符串匹配算法

下面的代码描述的是一个朴素的字符串匹配算法，它用一个循环来找出所有有效位移，该循环对n-m+1个可能的每一个s值检查条件P[1..m]=T[s+1..s+m]。

{% highlight c %}
void strStr2(char *haystack, char *needle)
{
	int n = strlen(haystack);
	int m = strlen(needle);
	int s = 0;
	while (s <= n - m) {
		if (strncmp(needle, haystack + s, m) == 0)
			printf("%d\n", s);
		s++;
	}
}
{% endhighlight %}

在最坏情况下，这种算法的运行时间为O((n-m+1)m)。

这种朴素字符串匹配算法的效率不高，其原因在于对于s的一个值，我们获得的关于文本的信息在考虑s的其他值时完全被忽略了。这样的信息可能是非常有用的。

## 2 Rabin-Karp 算法

这个算法说白了就是把字符串转换成整数，然后来比较两个整数是否相等，考虑到可能会溢出，又取个余。然后余数相等的才比较两者是否相等。

{% highlight C++ %}
void rabinKarpMather(char *T, char *P, int d, int q)
{
	int n = strlen(T);
	int m = strlen(P);
	int p = 0;
	int h = 1;
	int t = 0;

	for (int i = 0; i < m; i++) {
		p = (d * p + P[i]) % q;
		t = (d * t + T[i]) % q;
		if (i < m - 1)
			h = (h * d) % q;
	}

	for (int s = 0; s < n - m; s++) {
		if (p == t && strncmp(T + s, P, m) == 0)
			printf("%d\n", s);
		if (s < n - m) {
			t = (d * (t - T[s] * h) + T[s + m]) % q;
		}
	}
}

// test
void rabinKarpMather()
{
	char *T = "1234567890";
	char *P = "234";
	rabinKarpMather(T, P, 10, 3793171);
}
{% endhighlight %}

其中函数的第三个参数d是匹配字符串的字母集，若匹配字符串只包含数字，则为10；若匹配字符串包含数字和字母，则为36（10个数字加上26个字母）。

因为转换为整数可能会溢出，所以取模q，q一般为素数且很大。

## 3 利用有限自动机进行字符串匹配

有两个关键点：

1. 明白有限自动机的概念。
2. 对于文本T中匹配模式P，在构造了自动机后，自动机与谁匹配。

### 3.1 有限自动机

一个有限自动机M是一个5元组：

1. 状态的有限集合，
2. 初始状态，
3. 一个接受状态的集合，
4. 有限的输入字母表，
5. 转移函数。

### 3.2 字符串匹配自动机

首先需要理解书上的引理32.2（后缀函数不等式）、引理32.3（后缀函数递归引理）和定理32.4。

然后需要理解后缀函数的定义。

之后需要理解在给定模式P[1...m]，其对应的字符串匹配自动机定义。书上翻译的不是很好，事实上，在匹配文本到T[i]时，其状态为q，模式P的最长前缀PQ同时是文本T[1...i]的最长后缀。接下来匹配文本T[i+1]时，连接字符串PQ与T[i+1]为PR，只需要求出PR的最长后缀同时是P的最长前缀，该最长后缀的长度即为此时的状态。

## 4 Knuth-Morris-Pratt 算法（KMP算法）

这个算法不用计算变迁函数，匹配时间为O(n)，只用到辅助函数（即前缀函数）t[1,m]，它是在O(m)时间内，根据模式预先计算出来的。

模式的前缀函数t包含有模式其自身的位移进行匹配的信息。这些信息可用于避免在朴素的字符串匹配算法中，对无用位移进行测试，也可以避免在字符串匹配自动机中，对变迁函数的预先计算过程。
